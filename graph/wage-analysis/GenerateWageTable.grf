<?xml version="1.0" encoding="UTF-8"?><Graph author="hankmobley" created="Thu Sep 22 10:24:29 EDT 2016" description="This massages the original fair pay data sources into a smaller, more managable table to&#10;act as the data source for later, more coplex queries to generate reports.&#10;&#10;At the time of this writing, only glassdoor data is being used, but we could add other &#10;sources later.&#10;&#10;In additoin to creating the lookup table, it also cleans up a few issues with fips matching&#10;and adds some titles (e..g., software engineer 3 - 5 years)" guiVersion="3.4.4.P" id="1474554360353" licenseType="Commercial" modified="Thu May 11 00:23:42 EDT 2017" modifiedBy="hankmobley" name="FairPayGenerateLookupTables" revision="1.218" showComponentDetails="true">
<Global>
<Connection database="DSS" dbURL="jdbc:dss://secure.gooddata.com/gdc/dss/instances/d68eb234fff8f2750cbf7dd02b20fd0e" id="JDBC0" jdbcSpecific="DSS" name="GOODDATA_DEV" password="justcapital1!" type="JDBC" user="ps-etl+justcapital_research@gooddata.com"/>
<Property id="GraphParameter2" name="STG_TABLE_GOC_SALARY_ADJUSTMENT" value="${STG_BASE}GOC_SALARY_ADJUSTMENT"/>
<Property id="GraphParameter3" name="STG_TABLE_JOB_LEVEL" value="${STG_BASE}JOB_LEVEL"/>
<Property id="GraphParameter4" name="TMP_TABLE_TICKER_COMPANY_NAME" value="${TMP_BASE}_TICKER_COMPANY_NAME"/>
<Property fileURL="wage.prm" id="GraphParameter38"/>
<Property fileURL="wage-staging.prm" id="GraphParameter5"/>
<Property fileURL="workspace.prm" id="GraphParameter20"/>
<Dictionary/>
</Global>
<Phase number="0">
<Node enabled="disabled" graphName="${GRAPH_DIR}/wage-analysis/GenerateFIPSData.grf" guiName="Generate FIPS Data" guiX="293" guiY="102" id="GENERATE_FIPS_DATA" type="RUN_GRAPH"/>
<Node enabled="disabled" graphName="${GRAPH_DIR}/H1BVisaEnigma.grf" guiName="Load Staging Data: Enigma" guiX="496" guiY="6" id="LOAD_STAGING_DATA_ENIGMA" type="RUN_GRAPH"/>
<Node enabled="disabled" graphName="${GRAPH_DIR}/GlassdoorSalaryData.grf" guiName="Load Staging Data: Glassdoor" guiX="1" guiY="6" id="LOAD_STAGING_DATA_GLASSDOOR" type="RUN_GRAPH"/>
<Node enabled="disabled" graphName="${GRAPH_DIR}/GlassdoorFranchiseSalaryData.grf" guiName="Load Staging Data: Glassdoor Franchise" guiX="444" guiY="102" id="LOAD_STAGING_DATA_GLASSDOOR_FRANCHISE" type="RUN_GRAPH"/>
<Node enabled="disabled" graphName="${GRAPH_DIR}/fairpay-livingwage/shared/data-loading/GOCSalaryAdjustments.grf" guiName="Load Staging Data: GOC Salary Adjustments" guiX="7" guiY="102" id="LOAD_STAGING_DATA_GOC_SALARY_ADJUSTMENTS" type="RUN_GRAPH"/>
<Node enabled="disabled" graphName="${GRAPH_DIR}/wage-analysis/data-loading/TickerDataSourceCompany.grf" guiName="Load Staging Data: Ticker Glassdoor Company" guiX="201" guiY="6" id="LOAD_STAGING_DATA_TICKER_GLASSDOOR_COMPANY" type="RUN_GRAPH"/>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Staging Table: Data Source" guiX="552" guiY="403" id="STAGING_TABLE_DATA_SOURCE" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[drop table if exists ${STG_TABLE_WAGE_DATA_SOURCE};
create table ${STG_TABLE_WAGE_DATA_SOURCE} (
  DATA_SOURCE_ID INTEGER UNIQUE NOT NULL,
  DATA_SOURCE VARCHAR(255) NOT NULL
);]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Staging Table: Job Level" guiX="1" guiY="403" id="STAGING_TABLE_JOB_LEVEL" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  ${STG_TABLE_JOB_LEVEL}
  Table to store level adjustments for goc.
  For example, software engineer with 0-3 years
  experience becomes software engineer 1
  again we may want to include this in a good data graph
*/
drop table if exists ${STG_TABLE_JOB_LEVEL};
create table ${STG_TABLE_JOB_LEVEL} (
  GOC VARCHAR(255) NOT NULL,
  GOC_WITH_LEVEL VARCHAR(255) NOT NULL,
  MIN_YEARS_EXPERIENCE INT NULL,
  MAX_YEARS_EXPERIENCE INT NULL
);
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Staging Table: JOC Adjustment" guiX="746" guiY="291" id="STAGING_TABLE_JOC_ADJUSTMENT" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[drop table if exists ${STG_TABLE_JOC_ADJUSTMENT};
create table ${STG_TABLE_JOC_ADJUSTMENT} (
  JOC VARCHAR(64) NULL,
  ORIGINAL VARCHAR(64) NULL,
  REASON_CODE INTEGER NULL
);]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Staging Table: JOC Adjustment Reason" guiX="739" guiY="364" id="STAGING_TABLE_JOC_ADJUSTMENT_REASON" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[drop table if exists ${STG_TABLE_JOC_ADJUSTMENT_REASON};
create table ${STG_TABLE_JOC_ADJUSTMENT_REASON} (
  REASON_CODE INTEGER UNIQUE NOT NULL,
  REASON_SHORT VARCHAR(16) UNIQUE NOT NULL,
  REASON_LONG VARCHAR(255) NOT NULL
);]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Staging Table: Salary Yr Adj " guiX="180" guiY="364" id="STAGING_TABLE_SALARY_YR_ADJ" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  ${STG_TABLE_SALARY_ADJ_BY_YEAR} 
  salary adjustments based on the year of the reported salary.  These 
  numbers came from Andy S. and apply to the year 2016. These would 
  need to be adjusted annually.  Might want to move this into a separate 
  file eventually.
*/
drop table if exists ${STG_TABLE_SALARY_ADJ_BY_YEAR};
create table ${STG_TABLE_SALARY_ADJ_BY_YEAR} (
  YEAR INT NOT NULL UNIQUE,
  ADJUSTMENT_FACTOR FLOAT NOT NULL
);
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Table: PPI Avgs" guiX="392" guiY="403" id="TABLE_PPI_AVGS" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  ${TABLE_PPI_AVG} 
  average cost os living index for city/state pairs.
  For counties (most) that have only one city/state pair, value will be for
  just that county. 
  For others (e.g., NEW YORK< NY with 5 counties) the average is taken and 
  assigned to each state_county_fips with that city/state pair (e.g., 
  the 5 counties for NEW YORK, NY would have 5 entries in this table, each 
  with the same average cost of living index).
*/
drop table if exists ${TABLE_PPI_AVG};
create table ${TABLE_PPI_AVG} (
  STATE_COUNTY_FIPS VARCHAR(5) NOT NULL,
  AVG_COST_OF_LIVING_INDEX FLOAT NOT NULL
);
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Table: Wage" guiX="335" guiY="206" id="TABLE_WAGE" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[drop table if exists ${TABLE_WAGE};
create table ${TABLE_WAGE} (
  DATA_SOURCE_ID INT NOT NULL,
  RECORD_ID VARCHAR(255) NULL,
  CITY VARCHAR(255) NOT NULL,
  STATE VARCHAR(2) NOT NULL,
  TICKER VARCHAR(16) NOT NULL,
  JOC VARCHAR(128) NOT NULL,
  JOB_TITLE VARCHAR(128) NOT NULL,
  HOURLY_WAGE_RAW FLOAT NOT NULL,
  HOURLY_WAGE_COLA FLOAT NOT NULL,
  WAGE_YEAR INT NULL,
  YEARS_OF_EXPERIENCE INT NULL
);]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="enabled" guiName="Temp Table: Ticker Company Name" guiX="68" guiY="206" id="TEMP_TABLE_TICKER_COMPANY_NAME1" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  ${TMP_TABLE_TICKER_COMPANY_NAME} 
  union of all company tickers and mapped names
*/
drop table if exists ${TMP_TABLE_TICKER_COMPANY_NAME};
create table ${TMP_TABLE_TICKER_COMPANY_NAME} (
  TICKER VARCHAR(16) NOT NULL,
  COMPANY_NAME VARCHAR(255) NOT NULL
);
]]></attr>
</Node>
</Phase>
<Phase number="1">
<Node dbConnection="JDBC0" enabled="disabled" guiName="Populate Data Source" guiX="552" guiY="442" id="POPULATE_DATA_SOURCE" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[insert into ${STG_TABLE_WAGE_DATA_SOURCE} values(0, 'Glassdoor');
insert into ${STG_TABLE_WAGE_DATA_SOURCE} values(1, 'EnigmaHB1');
insert into ${STG_TABLE_WAGE_DATA_SOURCE} values(2, 'Franchise');
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Populate Job Levels" guiX="22" guiY="442" id="POPULATE_JOB_LEVELS" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[insert into ${STG_TABLE_JOB_LEVEL} values('software engineer', 'software engineer < 3 years', null, 3);
insert into ${STG_TABLE_JOB_LEVEL} values('software engineer', 'software engineer 3 - 5 years', 3, 5);
insert into ${STG_TABLE_JOB_LEVEL} values('software engineer', 'software engineer 5 - 10 years', 5, 10);
insert into ${STG_TABLE_JOB_LEVEL} values('software engineer', 'software engineer > 10 years', 10, null);
insert into ${STG_TABLE_JOB_LEVEL} values('software qa', 'software qa < 3 years', null, 3);
insert into ${STG_TABLE_JOB_LEVEL} values('software qa', 'software qa 3 - 5 years', 3, 5);
insert into ${STG_TABLE_JOB_LEVEL} values('software qa', 'software qa 5 - 10 years', 5, 10);
insert into ${STG_TABLE_JOB_LEVEL} values('software qa', 'software qa > 10 years', 10, null);
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Populate JOC Adjustment Reason" guiX="739" guiY="442" id="POPULATE_JOC_ADJUSTMENT_REASON" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[insert into ${STG_TABLE_JOC_ADJUSTMENT_REASON} values (0,'MARRIOTT','Marriott franchise data had a special case for maintenence workers.');
insert into ${STG_TABLE_JOC_ADJUSTMENT_REASON} values (1,'JOBTITLE','Override based on job titles specified in ${}. ${} wes populated from a manually created excel file.');
insert into ${STG_TABLE_JOC_ADJUSTMENT_REASON} values (2,'GOCOVERRIDE','Override based on tickers specified in ${}. ${} wes populated from a manually created excel file.');
insert into ${STG_TABLE_JOC_ADJUSTMENT_REASON} values (3,'JOBLEVEL','Append levels based on years of experience for certain jobs as specified in ${}. ${} wes populated from hard-coded values in a module of the wage graph.');
insert into ${STG_TABLE_JOC_ADJUSTMENT_REASON} values (4,'H1BOVERRIDE','Append . Overrides based on hard-coded values in a module of the wage graph.');
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Populate PPI Avgs" guiX="391" guiY="442" id="POPULATE_PPI_AVGS1" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[insert into ${TABLE_PPI_AVG}
select 
  f.state_county_fips, cast(round(avg(a.avg_cost_of_living_index),1) as numeric(16,1)) avg_cost_of_living_index
from (
  select state_county_fips, city_name city, state_abbreviation state
  from  ${TABLE_CITY_FIPS} f
  group by state_county_fips, city_name, state_abbreviation
) f join (
  select f.city_name city, f.state_abbreviation state, avg(p.cost_of_living_index) avg_cost_of_living_index
  from ${TABLE_CITY_FIPS} f
  join ${STG_TABLE_REGIONAL_PURCHASING_POWER} p on f.state_county_fips = p.fips_code
  group by f.state_abbreviation, f.city_name
) a on f.city = a.city and f.state = a.state
group by f.state_county_fips;
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Populate Salary Yr Adj" guiX="196" guiY="442" id="POPULATE_SALARY_YR_ADJ" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[insert into ${STG_TABLE_SALARY_ADJ_BY_YEAR} values(2010, 1.127);
insert into ${STG_TABLE_SALARY_ADJ_BY_YEAR} values(2011, 1.105);
insert into ${STG_TABLE_SALARY_ADJ_BY_YEAR} values(2012, 1.083);
insert into ${STG_TABLE_SALARY_ADJ_BY_YEAR} values(2013, 1.063);
insert into ${STG_TABLE_SALARY_ADJ_BY_YEAR} values(2014, 1.042);
insert into ${STG_TABLE_SALARY_ADJ_BY_YEAR} values(2015, 1.020);
insert into ${STG_TABLE_SALARY_ADJ_BY_YEAR} values(2016, 1.000);
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="enabled" guiName="Populate Ticker Company Name" guiX="79" guiY="284" id="POPULATE_TICKER_COMPANY_NAME" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[insert into ${TMP_TABLE_TICKER_COMPANY_NAME}
select ticker, company_name
from ${TABLE_TICKER_COMPANY_NAME} tc
union all
select ticker, company_name
from ${TABLE_COMPANY} c;

]]></attr>
</Node>
</Phase>
<Phase number="2">
<Node dbConnection="JDBC0" enabled="disabled" guiName="Populate Wage Table with Glassdoor Data" guiX="199" guiY="519" id="POPULATE_WAGE_TABLE_WITH_GLASSDOOR_DATA" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[SET LOCALE to LEN_S1;

insert into ${TABLE_WAGE}
select distinct
  ds.data_source_id,
  g.fk_reviewid,
  fd.city,
  fd.state,
  tc.ticker,
  g.goc,
  g.jobtitle,
  cast(round(ya.ADJUSTMENT_FACTOR*g.UNADJUSTEDBASESALARY/(${CONST_HOURS_PER_YEAR})) as numeric(36,2)),
  cast(round(ya.ADJUSTMENT_FACTOR*g.UNADJUSTEDBASESALARY*100/(${CONST_HOURS_PER_YEAR}*isnull(fd.avg_cost_of_living_index,'100'))) as numeric(36,2)),
  cast(g.YEAROFSALARY as int),
  cast(g.YEARSOFRELEVANTEXPNUMBER as int)
from ${TMP_TABLE_TICKER_COMPANY_NAME} tc
join ${STG_TABLE_GLASSDOOR_WAGE} g on g.employer = tc.company_name
join ${STG_TABLE_SALARY_ADJ_BY_YEAR} ya on ya.year = cast(g.YEAROFSALARY as int)
join ${TABLE_WAGE_DATA_SOURCE} ds on ds.data_source = ${CONST_DATA_SOURCE_NAME_GLASSDOOR}
join ${TABLE_FIPS_DATA} fd on fd.city = g.cityname and fd.state = g.stateabbreviation
/*
left join (
  select 
    max(f.state_county_fips) state_county_fips,
    f.city_name city, 
    f.state_abbreviation state, 
    max(p.avg_cost_of_living_index) avg_cost_of_living_index
  from ${TABLE_CITY_FIPS} f
  join ${TABLE_PPI_AVG} p on p.state_county_fips = f.state_county_fips
  group by f.city_name, f.state_abbreviation
) p on p.city = g.cityname and p.state = g.statename
*/
where
  g.goc is not null and
  g.jobtitle is not null and
  g.unadjustedbasesalary is not null;]]></attr>
</Node>
</Phase>
<Phase number="3">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Populate Lookup Table with Enigma Data" guiX="201" guiY="673" id="POPULATE_LOOKUP_TABLE_WITH_ENIGMA_DATA1" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  insert enigma h1b visa data into ${TABLE_WAGE}
*/

SET LOCALE to LEN_S1;

insert into ${TABLE_WAGE}
select 
  ds.data_source_id,
  null reviewid,
  t.city,
  t.state, 
  t.ticker,
  t.joc,
  t.jobtitle,
  cast(round((t.wage / ${CONST_HOURS_PER_YEAR}),2) as numeric(36,2)) wage,
  cast(round((t.wage * 100.0 / f.avg_cost_of_living_index) / ${CONST_HOURS_PER_YEAR},2) as numeric(36,2)) wage_cola,
  t.wage_year,
  null years_of_experience
from (
  select
    ticker,
    joc,
    jobtitle,
    case 
      when wage_unit = 'Hour' then wage * ${CONST_HOURS_PER_YEAR}
      when wage_unit = 'Bi-Weekly' then wage * 26.0
      when wage_unit = 'Week' then wage * 52.0
      when wage_unit = 'Month' then wage * 12.0
      else wage
    end wage,
    city,
    state,
    wage_year
  from (
    select
      c.ticker,
      sg.gd_goc joc,
      e.job_title jobtitle,
      cast(round(
        case
          when e.wage_rate_of_pay_from > 0.0 and e.wage_rate_of_pay_to > 0.0
          then (e.wage_rate_of_pay_from + e.wage_rate_of_pay_to)/2.0
          when e.wage_rate_of_pay_from > 0.0
          then e.wage_rate_of_pay_from
          else e.wage_rate_of_pay_to
        end
      ,2) as numeric(16,2)) wage,
      e.wage_rate_of_pay wage_unit,
      case
        when e.worksite_city is null or e.worksite_state is null then employer_city
        else e.worksite_city
      end city,
      case
        when e.worksite_city is null or e.worksite_state is null then employer_state
        else e.worksite_state
      end state,
      cast(isnull(concat('20',right(e.employment_start_date,2)),isnull(e.pw_wage_source_year,cast(EXTRACT(YEAR FROM CURRENT_DATE) as varchar(4)))) as int) wage_year
    from (
      select
        employer_name,
        soc_code,
        job_title,
        wage_rate_of_pay,
        worksite_city,
        employer_city,
        worksite_state,
        employer_state,
        pw_wage_source_year,
        employment_start_date,
        case 
          when wage_rate_of_pay_from is null or not regexp_like(wage_rate_of_pay_from,'^[0-9.]+$') then 0.0
          else cast(wage_rate_of_pay_from as float)
        end wage_rate_of_pay_from,
        case 
          when wage_rate_of_pay_to is null or not regexp_like(wage_rate_of_pay_to,'^[0-9.]+$') then 0.0
          else cast(wage_rate_of_pay_to as float)
        end wage_rate_of_pay_to
      from ${STG_TABLE_ENIGMA_H1BVISA}
    ) e
    join ${TMP_TABLE_TICKER_COMPANY_NAME} c on c.company_name = e.employer_name
    join ${TABLE_SOC_GOC} sg on sg.enigma_soc_code = e.soc_code
    where
      (wage_rate_of_pay_from> 0.0 or wage_rate_of_pay_to > 0.0) and ( 
        (not (wage_rate_of_pay_from > 0.0 and wage_rate_of_pay_to > 0.0)) or 
        (wage_rate_of_pay_to >= wage_rate_of_pay_from)
      )
  ) t
) t
join ${TABLE_FIPS_DATA} f on f.city = t.city and f.state = t.state
join ${TABLE_WAGE_DATA_SOURCE} ds on ds.data_source = ${CONST_DATA_SOURCE_NAME_ENIGMAH1B}
join ${STG_TABLE_SALARY_ADJ_BY_YEAR} adj on adj.year = t.wage_year
where
  ((t.wage * 100.0 / f.avg_cost_of_living_index) / ${CONST_HOURS_PER_YEAR}) <= ${CONST_ENIGMA_H1BVISA_MAX_HOURLY_WAGE}
order by t.ticker, t.joc, t.wage desc;]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Populate Lookup Table with Franchise Data" guiX="194" guiY="597" id="POPULATE_LOOKUP_TABLE_WITH_FRANCHISE_DATA" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  insert enigma h1b visa data into ${SALARY_LOOKUP_TABLENAME}
*/
SET LOCALE to LEN_S1;

insert into ${TABLE_WAGE}
select
  ds.data_source_id,
  null reviewid,
  t.city,
  t.state, 
  t.ticker,
  t.goc joc,
  t.jobtitle,
  cast(round((t.UNADJUSTEDBASESALARY / ${CONST_HOURS_PER_YEAR}),2) as numeric(36,2)) UNADJUSTEDBASEHOURLY,
  cast(round((t.UNADJUSTEDBASESALARY * 100.0 / t.avg_cost_of_living_index) / ${CONST_HOURS_PER_YEAR},2) as numeric(36,2)) UNADJUSTEDBASEHOURLY_COLA,
  null,
  null
from (
  select 
    company,
    ticker,
    indy,
    goc,
    jobtitle,
    (case
      when unit = 'hourly' then ${CONST_HOURS_PER_YEAR} 
      when unit = 'monthly' then 12.0
      else 1.0
    end) * ((min+max)/2) unadjustedbasesalary,
    city,
    state, 
    isnull(avg_cost_of_living_index,100.0) avg_cost_of_living_index
  from (
      select
        g.company,
        c.ticker,
        c.industry indy,
        goc,
        g.jobtitle,
        g.area city,
        g.state,
        unit,
        (case 
          when regexp_instr(range,'.*k.*k') > 0 then 1000.0
          else 1
        end)*min min,
        (case
          when regexp_instr(range,'.*k.*k') > 0 then 1000.0
          when regexp_instr(range,'.*k') > 0 then 1000.0
          else 1.0
        end)*max max,
        f.avg_cost_of_living_index
      from ${STG_TABLE_FRANCHISE_WAGE} g
      join ${STG_TABLE_FRANCHISE_JOBTITLE_TO_GOC} j on g.jobtitle = j.jobtitle
      join ${TMP_TABLE_TICKER_COMPANY_NAME} tc on tc.company_name = g.company
      join (
        select c.ticker, c.industry 
        from ${TABLE_COMPANY} c
        left join (select ticker from ${TABLE_WAGE} group by ticker) w on w.ticker = c.ticker
        where w.ticker is null) c on c.ticker = tc.ticker
      join ${TABLE_FIPS_DATA} f on f.city = g.area and f.state = g.state
    ) t
) t
join ${TABLE_WAGE_DATA_SOURCE} ds on ds.data_source = ${CONST_DATA_SOURCE_NAME_FRANCHISE}
where unadjustedbasesalary >= ${CONST_FRANCHISE_MIN_YEARLY_SALARY} and unadjustedbasesalary <= ${CONST_FRANCHISE_MAX_YEARLY_SALARY}
order by ticker, goc, unadjustedbasesalary desc;
]]></attr>
</Node>
</Phase>
<Phase number="4">
<Node dbConnection="JDBC0" enabled="disabled" guiName="Clean up City FIPS Table" guiX="68" guiY="749" id="CLEAN_UP_CITY_FIPS_TABLE" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  FIPS data for Virginia was off for some reason, so need to adjust. 
  Again, this should probably should be in a separate file as it does 
  not need to be run every time we get new glass door data.
*/
update lkp_city_fips
set 
  county_fips = '944',
  state_county_fips = '51944',
  county_name = 'Roanoke + Salem'
where city_name = 'ROANOKE' and state_abbreviation = 'VA';
update lkp_city_fips
set 
  county_fips = '933',
  state_county_fips = '51933',
  county_name = 'Montgomery + Radford'
where city_name = 'BLACKSBURG' and state_abbreviation = 'VA';
update lkp_city_fips
set 
  county_fips = '901',
  state_county_fips = '51901',
  county_name = 'Albemarle + Charlottesville'
where city_name = 'CHARLOTTESVILLE' and state_abbreviation = 'VA';
update lkp_city_fips
set 
  county_fips = '911',
  state_county_fips = '51911',
  county_name = 'Campbell + Lynchburg'
where city_name = 'LYNCHBURG' and state_abbreviation = 'VA';
update lkp_city_fips
set 
  county_fips = '929',
  state_county_fips = '51929',
  county_name = 'Henry + Martinsville'
where city_name = 'MARTINSVILLE' and state_abbreviation = 'VA';
update lkp_city_fips
set 
  county_fips = '947',
  state_county_fips = '51947',
  county_name = 'Rockingham + Harrisonburg'
where city_name = 'HARRISONBURG' and state_abbreviation = 'VA';
update lkp_city_fips
set 
  county_fips = '907',
  state_county_fips = '51907',
  county_name = 'Augusta, Staunton + Waynesboro'
where city_name = 'STAUNTON' and state_abbreviation = 'VA';
update lkp_city_fips
set 
  county_fips = '921',
  state_county_fips = '51921',
  county_name = 'Frederick + Winchester'
where city_name = 'WINCHESTER' and state_abbreviation = 'VA';
update lkp_city_fips
set 
  county_fips = '951',
  state_county_fips = '51951',
  county_name = 'Spotsylvania + Fredericksburg'
where city_name = 'DANVILLE' and state_abbreviation = 'VA';]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Update Marriott Maintenance" guiX="232" guiY="826" id="UPDATE_MARRIOTT_MAINTENANCE" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  Since Marriott data was included in the original
  dataset, the franchise jobtitle/goc mappings were
  not applied. For now, just makikng an exeception
  for that case (specifically with maintenance titles). 
  Perhaps in the future we can implement a more general case. 
*/
SET LOCALE to LEN_S1;
update ${SALARY_LOOKUP_TABLENAME} s
set goc = u.goc
from ${FRANCHISE_JOBTITLE_TO_GOC_TABLENAME} u
where u.jobtitle = s.jobtitle and s.ticker = 'MAR' and u.jobtitle like 'main%';]]></attr>
</Node>
</Phase>
<Phase number="5">
<Node dbConnection="JDBC0" enabled="disabled" guiName="Update Job Names" guiX="255" guiY="903" id="UPDATE_JOB_NAMES1" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  update ${SALARY_LOOKUP_TABLENAME} to modify goc for various
  job titles. Basically, what we did was first generate a list
  of all glassdoor entries that included the word software or
  assistant. Then Andy S. and Rich D. went through all 4000+ entries 
  and set appropriate goc for given job title, the idea being we should get
  more job titles that way. Finally, created a Good Data graph to
  upload that jobtitle->goc data into the table, LKP_GD_JOBTITLE_OVERRIDE_GOC
*/
update ${SALARY_LOOKUP_TABLENAME} s
set goc = u.goc
from LKP_GD_JOBTITLE_OVERRIDE_GOC u
where u.jobtitle = s.jobtitle;]]></attr>
</Node>
</Phase>
<Phase number="6">
<Node dbConnection="JDBC0" enabled="disabled" guiName="Update Franchise GOC Special Cases" guiX="212" guiY="979" id="UPDATE_FRANCHISE_GOC_SPECIAL_CASES" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  update ${SALARY_LOOKUP_TABLENAME} to change gocs for specific
  franchises. The idea is to combine certain gocs for certain
  tickers. (For example, for LBTY, we combined 'general manager'
  and 'manager' under the goc 'general manager').
*/
update ${SALARY_LOOKUP_TABLENAME} s
set goc = u.new_goc
from ${FRANCHISE_GOC_EXCEPTIONS_TABLENAME} u
where u.old_goc = s.goc and u.ticker = s.ticker;]]></attr>
</Node>
</Phase>
<Phase number="7">
<Node dbConnection="JDBC0" enabled="disabled" guiName="Apply GOC Salary Multipliers" guiX="234" guiY="1057" id="APPLY_GOC_SALARY_MULTIPLIERS" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[update ${SALARY_LOOKUP_TABLENAME} s
  set unadjustedbasesalary = multiplier * unadjustedbasesalary,
    unadjustedtotalsalary = multiplier * unadjustedtotalsalary,
    unadjustedbasesalary_cola = multiplier * unadjustedbasesalary_cola,
    unadjustedtotalsalary_cola = multiplier * unadjustedtotalsalary_cola,
    unadjustedbasehourly = multiplier * unadjustedbasehourly,
    unadjustedtotalhourly = multiplier * unadjustedtotalhourly,
    unadjustedbasehourly_cola = multiplier * unadjustedbasehourly_cola,
    unadjustedtotalhourly_cola = multiplier * unadjustedtotalhourly_cola
from ${GOC_SALARY_MULTIPLIERS_TABLENAME} m
where m.goc = s.goc and m.ticker = s.ticker;]]></attr>
</Node>
</Phase>
<Phase number="8">
<Node dbConnection="JDBC0" enabled="disabled" guiName="Add Job Levels" guiX="273" guiY="1134" id="ADD_JOB_LEVELS" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  update ${SALARY_LOOKUP_TABLENAME} to modify goc by level, given years of experience,
  see above for further explanation.
*/
update ${SALARY_LOOKUP_TABLENAME} s
set goc = l.goc_with_level
from ${STG_TABLE_JOB_LEVEL} l
where
  s.goc = l.goc and (
    (MIN_YEARS_EXPERIENCE is null and MAX_YEARS_EXPERIENCE is not null and s.YEARSOFRELEVANTEXPNUMBER <= MAX_YEARS_EXPERIENCE) or
    (MIN_YEARS_EXPERIENCE is not null and s.YEARSOFRELEVANTEXPNUMBER > MIN_YEARS_EXPERIENCE and MAX_YEARS_EXPERIENCE is null) or
    (MIN_YEARS_EXPERIENCE is not null and s.YEARSOFRELEVANTEXPNUMBER > MIN_YEARS_EXPERIENCE and MAX_YEARS_EXPERIENCE is not null and s.YEARSOFRELEVANTEXPNUMBER <= MAX_YEARS_EXPERIENCE)
  );
]]></attr>
</Node>
</Phase>
<Phase number="9">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Drop Temp Ticker Company Name" guiX="430" guiY="1209" id="DROP_TEMP_TICKER_COMPANY_NAME" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[DROP TABLE IF EXISTS ${TMP_TABLE_TICKER_COMPANY_NAME}]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="disabled" guiName="Update H1B Names" guiX="268" guiY="1209" id="UPDATE_H1B_NAMES" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[SET LOCALE to LEN_S1;

update ${SALARY_LOOKUP_TABLENAME}
set goc = 'software engineer h1b'
where goc = 'software engineer' and data_type_id = 1;]]></attr>
</Node>
</Phase>
</Graph>
