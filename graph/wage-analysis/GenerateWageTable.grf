<?xml version="1.0" encoding="UTF-8"?><Graph author="hankmobley" created="Thu Sep 22 10:24:29 EDT 2016" description="This massages the original fair pay data sources into a smaller, more managable table to&#10;act as the data source for later, more coplex queries to generate reports.&#10;&#10;At the time of this writing, only glassdoor data is being used, but we could add other &#10;sources later.&#10;&#10;In additoin to creating the lookup table, it also cleans up a few issues with fips matching&#10;and adds some titles (e..g., software engineer 3 - 5 years)" guiVersion="3.4.4.P" id="1474554360353" licenseType="Commercial" modified="Sun May 14 23:14:10 EDT 2017" modifiedBy="hankmobley" name="FairPayGenerateLookupTables" revision="1.315" showComponentDetails="true">
<Global>
<Connection database="DSS" dbURL="jdbc:dss://secure.gooddata.com/gdc/dss/instances/d68eb234fff8f2750cbf7dd02b20fd0e" id="JDBC0" jdbcSpecific="DSS" name="GOODDATA_DEV" password="justcapital1!" type="JDBC" user="ps-etl+justcapital_research@gooddata.com"/>
<Property id="GraphParameter0" name="TMP_TABLE_COMPANY_NAME_TICKER" value="${TMP_BASE}_COMPANY_NAME_TICKER"/>
<Property id="GraphParameter1" name="TMP_TABLE_FIPS_DATA_VALID_COLI" value="${TMP_BASE}_FIPS_DATA_VALID_COLI"/>
<Property fileURL="wage.prm" id="GraphParameter2"/>
<Property fileURL="wage-staging.prm" id="GraphParameter20"/>
<Property fileURL="workspace.prm" id="GraphParameter38"/>
<Dictionary/>
</Global>
<Phase number="0">
<Node enabled="disabled" graphName="${GRAPH_DIR}/wage-analysis/GenerateFIPSData.grf" guiName="Generate FIPS Data" guiX="345" guiY="11" id="GENERATE_FIPS_DATA" type="RUN_GRAPH"/>
<Node enabled="disabled" graphName="${GRAPH_DIR}/wage-analysis/data-loading/LoadData.grf" guiName="Load Staging Data" guiX="187" guiY="11" id="LOAD_STAGING_DATA" type="RUN_GRAPH"/>
<Node dbConnection="JDBC0" enabled="enabled" guiName="Table: Wage" guiX="316" guiY="115" id="TABLE_WAGE" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[drop table if exists ${TABLE_WAGE};
create table ${TABLE_WAGE} (
  DATA_SOURCE_ID INT NOT NULL,
  RECORD_ID VARCHAR(255) NULL,
  CITY VARCHAR(255) NOT NULL,
  STATE VARCHAR(2) NOT NULL,
  TICKER VARCHAR(16) NOT NULL,
  JOC VARCHAR(128) NOT NULL,
  JOB_TITLE VARCHAR(128) NOT NULL,
  HOURLY_WAGE_RAW FLOAT NOT NULL,
  HOURLY_WAGE_COLA FLOAT NOT NULL,
  WAGE_YEAR INT NULL,
  YEARS_OF_EXPERIENCE INT NULL
);]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="enabled" guiName="Temp Table: Company Name Ticker" guiX="68" guiY="115" id="TEMP_TABLE_COMPANY_NAME_TICKER" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  ${TMP_TABLE_COMPANY_NAME_TICKER} 
  union of all company tickers and mapped names
*/
drop table if exists ${TMP_TABLE_COMPANY_NAME_TICKER};
create table ${TMP_TABLE_COMPANY_NAME_TICKER} (
  COMPANY_NAME VARCHAR(255) UNIQUE NOT NULL,
  TICKER VARCHAR(16) NOT NULL
);
]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="enabled" guiName="Temp Table: FIPS Data with Valid COLI" guiX="462" guiY="115" id="TEMP_TABLE_FIPS_DATA_WITH_VALID_COLI" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  ${TMP_TABLE_FIPS_DATA_VALID_COLI} 
  filters out city/state entries that have more than
  one cola. These are cases where a state has two
  city's with the same name, but in totally different
  part of state. The city's may actually be a township
  and a city, but we have no way to distinguish, so 
  for purposes of determining the cost of living adjusted
  salary, they cannot be included in the averaging
  calculation.
*/
drop table if exists ${TMP_TABLE_FIPS_DATA_VALID_COLI};
create table ${TMP_TABLE_FIPS_DATA_VALID_COLI} (
  STATE VARCHAR(2) NOT NULL,
  CITY VARCHAR(128) NOT NULL,
  AVG_COST_OF_LIVING_INDEX FLOAT NOT NULL
);
]]></attr>
</Node>
</Phase>
<Phase number="1">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Populate Company Name Ticker" guiX="79" guiY="193" id="POPULATE_COMPANY_NAME_TICKER" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[insert into ${TMP_TABLE_COMPANY_NAME_TICKER}
select company_name, ticker
from ${TABLE_COMPANY_NAME_TICKER} tc
union all
select company_name, ticker 
from ${TABLE_COMPANY} c
union all
select 
  subsidiary_name company_name, 
  case 
    when ticker_subsidiary is null then ticker_parent
    else ticker_subsidiary
  end ticker
from ${TABLE_SUBSIDIARY} s;

]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="enabled" guiName="Populate FIPS Data with Valid COLI" guiX="471" guiY="193" id="POPULATE_FIPS_DATA_WITH_VALID_COLI" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[SET LOCALE to LEN_S1;

INSERT INTO ${TMP_TABLE_FIPS_DATA_VALID_COLI}
SELECT
  STATE,
  CITY,
  MAX(AVG_COST_OF_LIVING_INDEX) AVG_COST_OF_LIVING_INDEX
FROM (
  SELECT STATE, CITY, AVG_COST_OF_LIVING_INDEX
  FROM ${TABLE_FIPS_DATA}
  GROUP BY STATE, CITY, AVG_COST_OF_LIVING_INDEX
) f
GROUP BY STATE, CITY
HAVING count('x') = 1;]]></attr>
</Node>
</Phase>
<Phase number="2">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Populate Wage Table with Glassdoor Data" guiX="250" guiY="281" id="POPULATE_WAGE_TABLE_WITH_GLASSDOOR_DATA" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[SET LOCALE to LEN_S1;

insert into ${TABLE_WAGE}
select distinct
  ds.data_source_id,
  g.fk_reviewid,
  fd.city,
  fd.state,
  tc.ticker,
  g.goc,
  g.jobtitle,
  cast(round(ya.ADJUSTMENT_FACTOR*g.UNADJUSTEDBASESALARY/(${CONST_HOURS_PER_YEAR})) as numeric(36,2)),
  cast(round(ya.ADJUSTMENT_FACTOR*g.UNADJUSTEDBASESALARY*100/(${CONST_HOURS_PER_YEAR}*isnull(fd.avg_cost_of_living_index,'100.0'))) as numeric(36,2)),
  cast(g.YEAROFSALARY as int),
  cast(g.YEARSOFRELEVANTEXPNUMBER as int)
from ${TMP_TABLE_COMPANY_NAME_TICKER} tc
join ${TABLE_GLASSDOOR_WAGE} g on g.employer = tc.company_name
join ${TABLE_YEAR_ADJUSTMENT} ya on ya.year = cast(g.YEAROFSALARY as int)
join ${TABLE_WAGE_DATA_SOURCE} ds on ds.data_source = ${CONST_DATA_SOURCE_NAME_GLASSDOOR}
join ${TMP_TABLE_FIPS_DATA_VALID_COLI} fd on fd.city = g.cityname and fd.state = g.stateabbreviation
where
  g.goc is not null and
  g.jobtitle is not null and
  g.unadjustedbasesalary is not null;]]></attr>
</Node>
</Phase>
<Phase number="3">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Populate Lookup Table with Franchise Data" guiX="245" guiY="359" id="POPULATE_LOOKUP_TABLE_WITH_FRANCHISE_DATA" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  insert enigma h1b visa data into ${TABLE_WAGE}
*/
SET LOCALE to LEN_S1;

insert into ${TABLE_WAGE}
select
  t.data_source_id,
  null reviewid,
  t.city,
  t.state, 
  t.ticker,
  t.joc,
  t.jobtitle,
  cast(round((t.wage / ${CONST_HOURS_PER_YEAR}),2) as numeric(36,2)),
  cast(round((t.wage * 100.0 / t.avg_cost_of_living_index) / ${CONST_HOURS_PER_YEAR},2) as numeric(36,2)),
  null,
  null
from (
  select
    data_source_id,
    company,
    ticker,
    joc,
    jobtitle,
    (case
      when unit = 'hourly' then ${CONST_HOURS_PER_YEAR} 
      when unit = 'monthly' then 12.0
      else 1.0
    end) * ((min+max)/2) wage,
    city,
    state, 
    isnull(avg_cost_of_living_index,100.0) avg_cost_of_living_index
  from (
      select
        ds.data_source_id,
        g.company,
        c.ticker_match ticker,
        j.joc,
        g.jobtitle,
        g.area city,
        g.state,
        unit,
        (case 
          when regexp_instr(range,'.*k.*k') > 0 then 1000.0
          else 1
        end)*min min,
        (case
          when regexp_instr(range,'.*k.*k') > 0 then 1000.0
          when regexp_instr(range,'.*k') > 0 then 1000.0
          else 1.0
        end)*max max,
        f.avg_cost_of_living_index
      from ${TABLE_FRANCHISE_WAGE} g
      join ${TMP_TABLE_COMPANY_NAME_TICKER} tc on tc.company_name = g.company
      join ${TABLE_WAGE_DATA_SOURCE} ds on ds.data_source = ${CONST_DATA_SOURCE_NAME_FRANCHISE}
      join ${TABLE_JOBTITLE_JOC} j on 
                           (j.jobtitle = g.jobtitle) 
                           and ((j.ticker is null) or (j.ticker = tc.ticker))
                           and ((j.data_source is null) or (j.data_source = ds.data_source))
      join (
        select c.ticker_match, c.ticker 
        from (
          select s.ticker ticker_match, s.ticker
          from (
            select ticker_parent ticker 
            from ${TABLE_SUBSIDIARY} 
            where ticker_subsidiary is not null 
            group by ticker_parent
          ) s 
          union all
          select isnull(s.ticker_subsidiary,c.ticker) ticker_match, c.ticker
          from ${TABLE_COMPANY} c
          left join ${TABLE_SUBSIDIARY} s on s.ticker_parent = c.ticker
        ) c
        left join (
          select ticker, count('x') cnt
          from ${TABLE_WAGE} w 
          join ${TABLE_WAGE_DATA_SOURCE} ds on ds.data_source_id = w.data_source_id 
          where data_source = ${CONST_DATA_SOURCE_NAME_GLASSDOOR}
          group by ticker
        ) w on w.ticker = c.ticker_match
        where w.ticker is null
      ) c on c.ticker_match = tc.ticker
      join ${TMP_TABLE_FIPS_DATA_VALID_COLI} f on f.city = g.area and f.state = g.state
    ) t
) t
where wage >= ${CONST_FRANCHISE_MIN_YEARLY_SALARY} and wage <= ${CONST_FRANCHISE_MAX_YEARLY_SALARY}
order by ticker, joc, wage desc;
]]></attr>
</Node>
</Phase>
<Phase number="4">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Populate Lookup Table with Enigma Data" guiX="252" guiY="435" id="POPULATE_LOOKUP_TABLE_WITH_ENIGMA_DATA1" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  insert enigma h1b visa data into ${TABLE_WAGE}
*/

SET LOCALE to LEN_S1;

insert into ${TABLE_WAGE}
select 
  ds.data_source_id,
  null reviewid,
  t.city,
  t.state, 
  t.ticker,
  t.joc,
  t.jobtitle,
  cast(round((ya.ADJUSTMENT_FACTOR*t.wage / ${CONST_HOURS_PER_YEAR}),2) as numeric(36,2)) wage,
  cast(round((ya.ADJUSTMENT_FACTOR*t.wage * 100.0 / f.avg_cost_of_living_index) / ${CONST_HOURS_PER_YEAR},2) as numeric(36,2)) wage_cola,
  t.wage_year,
  null years_of_experience
from (
  select
    ticker,
    joc,
    jobtitle,
    case 
      when wage_unit = 'Hour' then wage * ${CONST_HOURS_PER_YEAR}
      when wage_unit = 'Bi-Weekly' then wage * 26.0
      when wage_unit = 'Week' then wage * 52.0
      when wage_unit = 'Month' then wage * 12.0
      else wage
    end wage,
    city,
    state,
    wage_year
  from (
    select
      c.ticker,
      sj.joc,
      e.job_title jobtitle,
      cast(round(
        case
          when e.wage_rate_of_pay_from > 0.0 and e.wage_rate_of_pay_to > 0.0
          then (e.wage_rate_of_pay_from + e.wage_rate_of_pay_to)/2.0
          when e.wage_rate_of_pay_from > 0.0
          then e.wage_rate_of_pay_from
          else e.wage_rate_of_pay_to
        end
      ,2) as numeric(16,2)) wage,
      e.wage_rate_of_pay wage_unit,
      case
        when e.worksite_city is null or e.worksite_state is null then employer_city
        else e.worksite_city
      end city,
      case
        when e.worksite_city is null or e.worksite_state is null then employer_state
        else e.worksite_state
      end state,
      cast(isnull(concat('20',right(e.employment_start_date,2)),isnull(e.pw_wage_source_year,cast(EXTRACT(YEAR FROM CURRENT_DATE) as varchar(4)))) as int) wage_year
    from (
      select
        employer_name,
        soc_code,
        soc_name,
        job_title,
        wage_rate_of_pay,
        worksite_city,
        employer_city,
        worksite_state,
        employer_state,
        pw_wage_source_year,
        employment_start_date,
        case 
          when wage_rate_of_pay_from is null or not regexp_like(wage_rate_of_pay_from,'^[0-9.]+$') then 0.0
          else cast(wage_rate_of_pay_from as float)
        end wage_rate_of_pay_from,
        case 
          when wage_rate_of_pay_to is null or not regexp_like(wage_rate_of_pay_to,'^[0-9.]+$') then 0.0
          else cast(wage_rate_of_pay_to as float)
        end wage_rate_of_pay_to
      from ${TABLE_ENIGMA_H1BVISA} e
      join ${TMP_TABLE_COMPANY_NAME_TICKER} tc on tc.company_name = e.employer_name
      where case_status = 'CERTIFIED' and length(soc_code) >= 7 and regexp_like(left(soc_code,7),'[0-9][0-9]\-[0-9][0-9][0-9][0-9]')
    ) e
    join ${TMP_TABLE_COMPANY_NAME_TICKER} c on c.company_name = e.employer_name
    join ${TABLE_ENIGMA_H1BVISA_JOC} sj on 
      sj.enigma_soc_code = e.soc_code
      and sj.enigma_soc_name = e.soc_name
      and sj.enigma_job_title = e.job_title
    where
      (wage_rate_of_pay_from> 0.0 or wage_rate_of_pay_to > 0.0) and ( 
        (not (wage_rate_of_pay_from > 0.0 and wage_rate_of_pay_to > 0.0)) or 
        (wage_rate_of_pay_to >= wage_rate_of_pay_from)
      )
  ) t
) t
join ${TMP_TABLE_FIPS_DATA_VALID_COLI} f on f.city = t.city and f.state = t.state
join ${TABLE_DATA_SOURCE} ds on ds.data_source = ${CONST_DATA_SOURCE_NAME_ENIGMAH1B}
join ${TABLE_YEAR_ADJUSTMENT} ya on ya.year = t.wage_year
where
  ((t.wage * 100.0 / f.avg_cost_of_living_index) / ${CONST_HOURS_PER_YEAR}) <= ${CONST_ENIGMA_H1BVISA_MAX_HOURLY_WAGE}
order by t.ticker, t.joc, t.wage desc;]]></attr>
</Node>
</Phase>
<Phase number="5">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Apply JOC Modifications" guiX="287" guiY="522" id="APPLY_JOC_MODIFICATIONS" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[SET LOCALE to LEN_S1;

update ${TABLE_WAGE} w
  set joc = j.joc
from (
  /*********************************************************************************
    Doing a union so that records with incorrect data source not accidently included 
  *********************************************************************************/
  select jobtitle, joc, data_source_id, ticker
  from ${TABLE_JOBTITLE_JOC} j
  left join ${TABLE_DATA_SOURCE} ds on ds.data_source = j.data_source
  where j.data_source is not null
  union all
  select jobtitle, joc, cast(null as integer) data_source_id, ticker
  from ${TABLE_JOBTITLE_JOC}
  where data_source is null
) j
where
  w.job_title = j.jobtitle 
  and (j.data_source_id is null or w.data_source_id = j.data_source_id)
  and (j.ticker is null or w.ticker = j.ticker);]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="enabled" guiName="Drop Temp FIPS Data Valid COLI" guiX="496" guiY="522" id="DROP_TEMP_FIPS_DATA_VALID_COLI" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[DROP TABLE IF EXISTS ${TMP_TABLE_FIPS_DATA_VALID_COLI}]]></attr>
</Node>
<Node dbConnection="JDBC0" enabled="enabled" guiName="Drop Temp Ticker Company Name" guiX="41" guiY="522" id="DROP_TEMP_TICKER_COMPANY_NAME" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[DROP TABLE IF EXISTS ${TMP_TABLE_COMPANY_NAME_TICKER}]]></attr>
</Node>
</Phase>
<Phase number="6">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Apply JOC Exceptions" guiX="293" guiY="606" id="APPLY_JOC_EXCEPTIONS1" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[SET LOCALE to LEN_S1;
update ${TABLE_WAGE} w
  set joc = j.joc_new
from (
  /*********************************************************************************
    Doing a union so that records with incorrect data source not accidently included 
  *********************************************************************************/
  select joc, joc_new, data_source_id, ticker
  from ${TABLE_JOC_EXCEPTION} j
  left join ${TABLE_DATA_SOURCE} ds on ds.data_source = j.data_source
  where j.data_source is not null
  union all
  select joc, joc_new, cast(null as integer) data_source_id, ticker
  from ${TABLE_JOC_EXCEPTION}
  where data_source is null
) j
where
  w.joc = j.joc
  and (j.data_source_id is null or w.data_source_id = j.data_source_id)
  and (j.ticker is null or w.ticker = j.ticker);]]></attr>
</Node>
</Phase>
<Phase number="7">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Apply JOC Exceptions" guiX="293" guiY="683" id="APPLY_JOC_EXCEPTIONS2" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[/*
  update ${TABLE_WAGE} to modify joc by level, given years of experience.
*/
SET LOCALE to LEN_S1;
update ${TABLE_WAGE} w
set joc = l.joc_with_level
from ${TABLE_JOB_LEVEL} l
where
  w.joc = l.joc and (
    (MIN_YEARS_EXPERIENCE is null and MAX_YEARS_EXPERIENCE is not null and w.YEARS_OF_EXPERIENCE <= MAX_YEARS_EXPERIENCE) or
    (MIN_YEARS_EXPERIENCE is not null and w.YEARS_OF_EXPERIENCE > MIN_YEARS_EXPERIENCE and MAX_YEARS_EXPERIENCE is null) or
    (MIN_YEARS_EXPERIENCE is not null and w.YEARS_OF_EXPERIENCE > MIN_YEARS_EXPERIENCE and MAX_YEARS_EXPERIENCE is not null and w.YEARS_OF_EXPERIENCE <= MAX_YEARS_EXPERIENCE)
  );
]]></attr>
</Node>
</Phase>
<Phase number="8">
<Node dbConnection="JDBC0" enabled="enabled" guiName="Apply JOC Wage Multipliers" guiX="277" guiY="761" id="APPLY_JOC_WAGE_MULTIPLIERS" type="DB_EXECUTE">
<attr name="sqlQuery"><![CDATA[SET LOCALE to LEN_S1;
update ${TABLE_WAGE} w
  set hourly_wage_raw = multiplier * hourly_wage_raw,
    hourly_wage_cola = multiplier * hourly_wage_cola
from ${TABLE_JOC_WAGE_MULTIPLIER} m
where w.joc = w.joc and w.ticker = m.ticker;]]></attr>
</Node>
</Phase>
</Graph>
